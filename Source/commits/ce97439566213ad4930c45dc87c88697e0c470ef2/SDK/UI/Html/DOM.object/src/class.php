<?php
//#section#[header]
// Namespace
namespace UI\Html;

// Use Important Headers
use \API\Platform\importer;
use \Exception;

// Check Platform Existance
if (!defined('_RB_PLATFORM_'))
	throw new Exception("Platform is not defined!");
//#section_end#
//#section#[class]
/**
 * @library	UI
 * @package	Html
 * 
 * @copyright	Copyright (C) 2015 DrovIO. All rights reserved.
 */

importer::import("API", "Resources", "DOMParser");
importer::import("ESS", "Prototype", "DOMPrototype");
importer::import("DEV", "Profiler", "logger");

use \DOMDocument;
use \DOMXPath;
use \API\Resources\DOMParser;
use \ESS\Prototype\DOMPrototype;
use \DEV\Profiler\logger;

/**
 * Document Object Model
 * 
 * Extends the DOM Prototype and is the base class for building all the html for the system pages.
 * 
 * @version	1.0-2
 * @created	March 15, 2013, 15:08 (EET)
 * @updated	July 27, 2015, 15:32 (EEST)
 */
class DOM extends DOMPrototype
{
	/**
	 * The page document
	 * 
	 * @type	DOMDocument
	 */
	protected static $document;
	
	/**
	 * Creates and returns a DOMElement with the specified tagName and the given attributes
	 * 
	 * @param	string	$tag
	 * 		The tag of the element.
	 * 
	 * @param	mixed	$content
	 * 		The content of the element. It can be a string or a DOMElement.
	 * 
	 * @param	string	$id
	 * 		The id attribute
	 * 
	 * @param	string	$class
	 * 		The class attribute
	 * 
	 * @return	DOMElement
	 * 		The DOMElement
	 */
	public static function create($tag = "div", $content = "", $id = "", $class = "")
	{
		// Check if the content is string or a DOMElement
		if (gettype($content) == "string")
		{
			$elem = self::$document->createElement($tag);
			$txtNode = self::$document->createTextNode($content);
			$elem->appendChild($txtNode);
		}
		else
		{
			$elem = self::$document->createElement($tag);
			if (gettype($content) == "object")
				$elem->appendChild($content);
		}
		

		if (!is_null($id) && !empty($id))
			self::attr($elem, "id", $id);
			
		if (!is_null($class) && !empty($class))
			self::attr($elem, "class", $class);
		
		return $elem;
	}
	
	/**
	 * Evaluate an XPath Query
	 * 
	 * @param	string	$query
	 * 		The XPath query to be evaluated
	 * 
	 * @param	DOMElement	$context
	 * 		The optional contextnode can be specified for doing relative XPath queries.
	 * 		By default, the queries are relative to the root element.
	 * 		It is NULL by default.
	 * 
	 * @return	mixed
	 * 		Returns a typed result if possible or a DOMNodeList containing all nodes matching the given XPath expression.
	 * 		If the expression is malformed or the contextnode is invalid, DOMXPath::evaluate() returns FALSE.
	 */
	public static function evaluate($query, $context = NULL)
	{
		$xpath = new DOMXPath(self::$document);
		$result = $xpath->evaluate($query, $context);
		if ($result === FALSE)
			logger::log("DOM::evaluate(). The expression is malformed or the contextnode is invalid.", logger::ERROR);
		
		return $result;
	}
	
	/**
	 * Find an element by id (using the evaluate function).
	 * 
	 * @param	string	$id
	 * 		The id of the element
	 * 
	 * @param	string	$nodeName
	 * 		The node name of the element. If not set, it searches for all nodes (*).
	 * 
	 * @return	mixed
	 * 		Returns the DOMElement or NULL if it doesn't exist.
	 */
	public static function find($id, $nodeName = "*")
	{
		$nodeName = (empty($nodeName) ? "*" : $nodeName);
		$q = "//".$nodeName."[@id='$id']";
		$list = self::evaluate($q);
		
		if ($list->length > 0)
			return $list->item(0);
		
		logger::log("DOM::find(). The node with id: [$id] is not found.", logger::WARNING);
		return NULL;
	}
	
	/**
	 * Create an html comment and returns the element.
	 * 
	 * @param	string	$content
	 * 		The comment content.
	 * 
	 * @return	DOMNode
	 * 		The comment node.
	 */
	public static function comment($content)
	{
		return self::$document->createComment($content);
	}
	
	/**
	 * Imports a node to this document. Returns the new node.
	 * 
	 * @param	DOMNode	$node
	 * 		The node to be imported
	 * 
	 * @param	boolean	$deep
	 * 		Defines whether all the children of this node will be imported
	 * 
	 * @return	DOMNode
	 * 		The imported node.
	 */
	public static function import($node, $deep = TRUE)
	{
		if (empty($node))
			return NULL;
		return self::$document->importNode($node, $deep);
	}
	
	/**
	 * Returns the HTML form of the document.
	 * 
	 * @param	boolean	$format
	 * 		Indicates whether to format the output.
	 * 
	 * @return	string
	 * 		The html generated by this document.,
	 */
	public function getHTML($format = FALSE)
	{
		self::$document->formatOutput = $format;
		return self::$document->saveHTML();
	}
	
	/**
	 * Returns the XML form of the document
	 * 
	 * @param	boolean	$format
	 * 		Indicates whether to format the output.
	 * 
	 * @return	string
	 * 		The xml generated by this document.
	 */
	public function getXML($format = FALSE)
	{
		self::$document->formatOutput = $format;
		return self::$document->saveXML();
	}
	
	/**
	 * Initializes and clears the  DOMDocument
	 * 
	 * @return	void
	 */
	public static function initialize()
	{
		self::$document = new DOMDocument("1.0", "UTF-8");
	}
	
	/**
	 * Clears the DOMDocument
	 * 
	 * @return	void
	 */
	public static function clear()
	{
		$root = self::evaluate("/")->item(0);
		foreach ($root->childNodes as $child)
			self::replace($child, NULL);
	}
	
	/**
	 * Get the DOMDocument
	 * 
	 * @return	DOMDocument
	 * 		The root document.
	 */
	public static function document()
	{
		return self::$document;
	}
	
	/**
	 * Parse a given DOMElement and transform it to html.
	 * 
	 * @param	DOMElement	$DOMElement
	 * 		The DOMElement element to be resolved/transformed to html.
	 * 
	 * @return	string
	 * 		The transformed html.
	 */
	public static function DOM2HTML($DOMElement)
	{
		// Create xml parser for engine
		$parser = new DOMParser();

		// Import and append given element
		$content = $parser->import($content);
		$parser->append($content);
		
		// Return exported html
		return $parser->getHTML();
	}
}
//#section_end#
?>